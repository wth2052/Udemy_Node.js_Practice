//비동기화 코드
//즉시 실행되거나 끝나지 않고
//시간이 소요됐음
// 이 비동기 코드에는 콜백함수를 인식시킬수있음
//함수는 나중에 실행됨(콜 백)
//타이머가 종료된 후 곧바로 다음 줄로 이동해
//모든 동기화 코드를 실행하고
//종료된뒤 다시 비동기를 실행함

const fetchData = ()=> {
  //Promise는 resolve, reject라는 두가지 인수를 콜백한다.
  const promise = new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve('Done!');
    }, 1500)
  });
  //동기화 코드, 프로미스 내부의 코드가 실행되기전에 프로미스가 생성된 직후 반환될것.
  //이 함수를 호출하고 이 타이머의 Done!이 완료되고 얼마 후
  //일어날 일임.
  //이제 프로미스를 여기서 반환하고 fetchData를 호출하는 자리에 then을 사용할수 있고, 프로미스를 반환할수 있게된다.
  return promise;

}

setTimeout(() => {
  console.log('Timer is done!');
  //함수를 콜백하기위해 텍스트가 전달되어 텍스트를 입력하고,
  //그 텍스트를 console.log 할수 있음
  //이 내부 타이머가 다른곳에서 완료되었을때 실행되는 함수를 정의할수있음
  // 위 함수는 callback으로 전달됨.

  //이렇게되면 then 블록이 연쇄적으로 구성되는데
  //첫번째 프로미스 다음에는
  //이 블록이 호출되고
  fetchData()
    //then 블록 내부에서 다른 프로미스를 반환한다.
    .then(text => {
      console.log(text);
      //프로미스를 전달하지 않는다고 해도 then 블록은 이걸 반환하는 대신
      //즉시 해결되는 프로미스로 전환하게 됨
      return fetchData();
    })
      //그리고 여기 이 프로미스에 관련된 다른 then 블록을 추가하면
      // 무한히 중첩된 콜백을 두는것 보다 훨씬 읽기 편함
    //done이 2번 나타나는 이유? fetchData를 2번 호출하기 때문!!!!
    //처음 접하면 어려울수 있음. 이런 코드는 직접 작성할 일이 없지만
    //비동기화 코드를 더 잘 관리할수있는 핵심.
    //이를 관리하는 다른 방법이 존재함
    //async await!!!!
        .then(text2 => {
        console.log(text2);
      });
}, 2000);
//만약 중첩된 비동기화 호출이
//여기에서처럼 몇 개 존재하는 경우
//우리는 콜백 시점에서 점점 더 깊게 들어가게 된다.
//그렇기 때문에 프로미스라는 기능을 Node.js에서 사용할수있음.
//이미 프로미스가 사용된 제3자 패키지가 자주 사용되는데
//하지만 알아둘필요는 있음
//fetchData에 Promise를 선언하러 고고~



//콜백함수가 잘못된것은 아니나 몇가지 의존성 비동기 작업의 경우
//문제에 직면하게 됨
//바로

console.log('Hello');
console.log('Hi');